Замеры скорости обработки запроса до модификации на таблице с миллионом строк:

Время выполнения запроса к БД: 0.1275320053100586 секунд
Время обработки вывода: 0.544670820236206 секунд
Общее время выполнения: 0.6722028255462646 секунд

Замеры скорости после модификации:

Время выполнения запроса к БД: 0.03299736976623535 секунд
Время обработки вывода: 0.5250041484832764 секунд
Общее время выполнения: 0.5580015182495117 секунд

Для оптимизации базы данных я решил применить партицированние. Прочитав официально руководство по данной продцедуре я увидел плюсы: ускорение выборки данных, ускорение вставки данных.
Понял что партицирование максимально эффективно работает, если нам известны самые частые запросы к базе,так как мы можем правильно выбрать условие для разделения.
Разделить таблицу я решил по критерию:
в первую подтаблицу отправятся все записи мужского пола, первая буква в которых 'F',
во вторую все остальные записи.
Далее по тексту объясняю что конкретно делает мой код в функции optimize_database():
- Подразумевается что моя таблица уже заполнена данными, поэтому для облегчения задачи разделения я создаю новую аналогичную таблицу.
- Создаю две дочерние таблицы, наследующиеся от новой таблицы. Добавляю к ним условия, описанные выше.
- Переношу в них данные из старой таблицы согласно условиям.
- Переименовываю основные таблицы, чтобы новая таблица стала главной. Удаляю старую таблицу.
- Обновлею текущее значение для id, для его корректного присвоения при дальнейших вставках данных в таблицу.
- Добавляю функцию для операторов INSERT, чтобы новые данные передавались в нужную дочернюю таблицу.
- Добавляю триггер, вызывающий эту функцию при вставке.
Тестирование скорости показало, что я добился кратного уменьшения времени запроса к БД.
Время вывода очевидно практически не изменилось, для его сокращения уже необходимо вносить правки в код самой функции.
